@namespace LeoLang.Core
@classname LeoParser
@using LeoLang.Core.AST
@using LeoLang.Core.AST.Expressions

@start methodDefinition

//Literals
numberLiteral<SyntaxNode> -public = value:("" [0-9]*) {SyntaxNode.CreateNumber(int.Parse(value))}
booleanLiteral<SyntaxNode> -public =  val:("true" / "false") { SyntaxNode.CreateBool(bool.Parse(val)) }
characterLiteral<SyntaxNode> -public = "'" c:("" [^']) "'" {SyntaxNode.CreateChar(c)}							

value<SyntaxNode> = booleanLiteral / numberLiteral / characterLiteral / defaultExpression / identifier

identifier<IdentifierNode> -public = id:("" ([a-zA-Z_][a-zA-Z_0-9]*)) {SyntaxNode.CreateID(id)}

expression<SyntaxNode> = binaryExpression / value

binaryOperator<BinaryOperator> = "<=" {BinaryOperator.LessEq}
							   / ">=" {BinaryOperator.GreaterEq}
							   / "==" {BinaryOperator.Equal}
							   / "<" {BinaryOperator.Less}
							   / ">" {BinaryOperator.Greater};

binaryExpression<SyntaxNode> -public = lhs:value _? op:binaryOperator _? rhs:value {SyntaxNode.CreateBinary(lhs, op, rhs)}


variableDefinition<SyntaxNode> = "let" _ id:identifier _ "=" _ val:expression 
										{SyntaxNode.CreateVarDef(id, val)}

label<SyntaxNode> = id:identifier Colon {SyntaxNode.CreateLabel(id)}

ifStatement<SyntaxNode> -public = "if" _? LBr _? cond:binaryExpression _? RBr _? body:Block {SyntaxNode.CreateIf(cond, body)}
whileStatement<SyntaxNode> -public = "while" _? LBr _? cond:binaryExpression _? RBr _? body:Block {SyntaxNode.CreateWhile(cond, body)}

Block<SyntaxNode> = _? LCb _? block:StatementLine* _? RCb _? Semi
					{SyntaxNode.CreateBlock(block)}

Statement<SyntaxNode> = goToStatement / variableDefinition / goToStatement / ifStatement / whileStatement
StatementLine<SyntaxNode> = stmt:Statement Semi {stmt}

paramDef<SyntaxNode> = type:identifier _ name:identifier {SyntaxNode.CreateParameter(type, name)}
paramList<SyntaxNode> -memoize = paramDef / paramListVoid
paramListVoid<SyntaxNode> = "void" {null}

methodDefinition<SyntaxNode> -public = ret:identifier _ id:identifier LBr param:paramList RBr body:Block
										{SyntaxNode.CreateMethod(id, ret, param, body)}	

defaultExpression<SyntaxNode> -public = "default" LBr id:identifier RBr {SyntaxNode.CreateDefault(id)}
										/ "default" {SyntaxNode.CreateDefault(null)}

goToStatement<SyntaxNode> = "goto" _ id:identifier {SyntaxNode.CreateGoTo(id)}
returnStatement<SyntaxNode> = "return" _ expr:expression {SyntaxNode.CreateReturn(expr)} / "pass" {SyntaxNode.CreateReturn(null)}

//Tokens
LBr -lexical = '('
RBr -lexical = ')'
LCb -lexical = '{'
RCb -lexical = '}'
Semi -lexical = ';'
Colon -lexical = ':'

whitespace = [\t ] / EOL
_ = whitespace+


EOL = '\n' / '\r' / '\r\n'
EOF = !.