@namespace LeoLang.Core.AST
@classname LeoParser
@using LeoLang.Core.AST
@using LeoLang.Core.AST.Expressions

@start CompilationUnit

CompilationUnitLine<SyntaxNode> = usingDeclaration  / enumDefinition / methodDefinition / structDeklaration / fieldDeklaration
CompilationUnit<SyntaxNode> -public = _o line:CompilationUnitLine* _o {SyntaxNode.CreateBlock(line)}

//Literals
integerLiteral<SyntaxNode> = value:("" [0-9]+) {SyntaxNode.CreateInteger(value)}
decimalLiteral<SyntaxNode> = value:("" [0-9]+ "." [0-9]+) {SyntaxNode.CreateDecimal(value)}
hexLiteral<SyntaxNode> = "0x" value:("" [0-9A-Za-z]+) {SyntaxNode.CreateHexInteger(value)}
binLiteral<SyntaxNode> = "0b" value:("" [01_]+) {SyntaxNode.CreateBinInteger(value)}
numberLiteral<SyntaxNode> = hexLiteral / binLiteral / decimalLiteral / integerLiteral
symbolLiteral<SyntaxNode> = ":" id:identifier {SyntaxNode.CreateSymbolLiteral(id)}

infixedSymbol<SymbolNode> = sp:symbolPrefix? id:identifier ss:symbolSuffix<0, 2> {((SymbolNode)id).SetInfix(sp, ss)}
symbolPrefix<SymbolPrefix> = pre:("++" / "--" / "-" / "*" / "&") {SyntaxNode.GetSymbolPrefix(pre)}
symbolSuffix<SymbolSuffix> = suf:("++" / "--" / "?" / "[]" / "*") {SyntaxNode.GetSymbolSuffix(suf)}

booleanLiteral<SyntaxNode> =  val:("true" / "false") { SyntaxNode.CreateBool(val) }
characterLiteral<SyntaxNode> = "'" c:("" [^']) "'" {SyntaxNode.CreateChar(c)}							
stringLiteral<SyntaxNode> = '"' val:("" simpleDoubleQuotedCharacter*) '"' {SyntaxNode.CreateString(val)}

value<SyntaxNode> -memoize = booleanLiteral / characterLiteral / stringLiteral / defaultExpression / sizeOfExpression / numberLiteral / unparsedBlock / identifier / symbolLiteral

identifier<SymbolNode> = id:("" ([a-zA-Z_][a-zA-Z_0-9]*)) {new SymbolNode(GSymbol.Get(id))}

expression<SyntaxNode> = binaryExpression / ternaryExpression/ value
unparsedBlock<SyntaxNode> -public = id:identifier _o LCb body:("" [^}]*) _o RCb _o
							{SyntaxNode.CreateUnparsedBlockExpression(id, body)}

usingDeclaration<SyntaxNode> -public = _o "using" _ ns:namespaceRule _o Semi
									{SyntaxNode.CreateUsing(ns)}

namespaceRule<SymbolNode>
	= f:identifier "." s:namespaceRule {SymbolNode.Join(f, s, '.')} / id:identifier

callExpression<SyntaxNode> -public = id:identifier _o LBr _o args:callparamlist _o RBr {SyntaxNode.CreateCall(id, args)}
callparamlist<IEnumerable<SyntaxNode>> = f:value _o "," _o s:callparamlist {SyntaxNode.Combine(f, s)} / v:value {SyntaxNode.Combine(v) }

fieldDeklaration<SyntaxNode> = mod:modifier? _o "field" _o type:identifier _ id:infixedSymbol _ "=" _ val:expression _o Semi
								{SyntaxNode.CreateField(mod, type, id, val)}

structDeklaration<SyntaxNode> -public = mod:modifier? _o "struct" _o id:identifier _o body:structBody
								{SyntaxNode.CreateStruct(mod, id, body)}
structBody<SyntaxNode> = f:fieldDeklaration* {SyntaxNode.CreateBlock(f)}								

binaryOperator<BinaryOperator> = "<=" {BinaryOperator.LessEq}
							   / ">=" {BinaryOperator.GreaterEq}
							   / "==" {BinaryOperator.Equal}
							   / "<" {BinaryOperator.Less}
							   / ">" {BinaryOperator.Greater};

binaryExpression<SyntaxNode> = lhs:value _o op:binaryOperator _o rhs:value {SyntaxNode.CreateBinary(lhs, op, rhs)}

ternaryExpression<SyntaxNode> -memoize = cond:binaryExpression _o "?" _o truePart:expression _o ":" _o falsePart:expression
										{SyntaxNode.CreateTernary(cond, truePart, falsePart)}
variableDefinition<SyntaxNode> = type:identifier _ id:infixedSymbol _ "=" _ val:expression 
										{SyntaxNode.CreateVarDef(type, id, val)}

label<SyntaxNode> = id:identifier Colon {SyntaxNode.CreateLabel(id)}

Block<SyntaxNode> -public = _o LCb block:blockContent _o RCb _o Semi _o
					{block}

blockContent<SyntaxNode> = lines:(StatementLine / genericStatementBlock)* {SyntaxNode.CreateBlock(lines)}
	
parameterContent<SyntaxNode>
	= _o head:paramDef _o "," _o tail:parameterContent { SyntaxNode.CreateParameter(head).Concat(tail) }
	/ line:paramDef { SyntaxNode.CreateParameter(line) }


Statement<SyntaxNode> = label / goToStatement / callExpression / variableDefinition / returnStatement 
StatementLine<SyntaxNode> = _o stmt:Statement _o Semi _o {stmt}
genericStatementBlock<SyntaxNode> = name:identifier _o LBr _o expr:expression _o RBr body:Block {SyntaxNode.CreateStatement(name, expr, body)}

paramDef<SyntaxNode> = type:identifier array:"[]"? _ name:identifier {SyntaxNode.CreateParameter(type, name, array)}
paramList<SyntaxNode> -memoize = parameterContent / paramListVoid / unexpected:&. #error{ "LLC0003: Expected void got '" + unexpected + "'" }
paramListVoid<SyntaxNode> = "void" {null}

methodDefinition<SyntaxNode> = mod:modifier? _o ret:infixedSymbol _ id:identifier LBr param:paramList RBr body:Block
										{SyntaxNode.CreateMethod(mod, id, ret, param, body)}	

enumDefinition<SyntaxNode> -public = mod:modifier? _o "enum" _ id:identifier type:enumType? _ LCb _o body:enumLine* _o RCb Semi
									{SyntaxNode.CreateEnum(mod, id, type, body)}
enumType<Symbol> = _o Colon _o id:identifier {id}
enumLine<SyntaxNode> = _o decl:enumFieldDeclaration _o Comma?
					   {decl}
enumFieldDeclaration<SyntaxNode> = enumFieldDefinition / id:identifier 
enumFieldDefinition<SyntaxNode> = id:identifier _o "=" _o val:enumValue {SyntaxNode.CreatePair(id, val)}
enumValue<SyntaxNode> = stringLiteral / characterLiteral / numberLiteral

defaultExpression<SyntaxNode> = "default" LBr id:identifier RBr {SyntaxNode.CreateDefault(id)}
										/ "default" {SyntaxNode.CreateDefault(null)}
sizeOfExpression<SyntaxNode> = "sizeof" LBr id:identifier RBr {SyntaxNode.CreateSizeOf(id)}

goToStatement<SyntaxNode> = "goto" _ id:identifier {SyntaxNode.CreateGoTo(id)}
returnStatement<SyntaxNode> = "return" _ expr:expression {SyntaxNode.CreateReturn(expr)} / "return" {SyntaxNode.CreateReturn(null)}

modifier<Symbol> = mod:("public" / "private" / "shared") {SyntaxNode.CreateModifier(mod)}

//Tokens
LBr -lexical = '('
RBr -lexical = ')'
LCb -lexical = '{'
RCb -lexical = '}'
Semi -lexical = ';'
Colon -lexical = ':'
Comma -lexical = ','

simpleDoubleQuotedCharacter
  = !('"' / "\\" / eolChar) char:. { @char }

whitespace = [\t ] / EOL
_ -memoize = (whitespace / EOL / comment)*
_o = _?

comment -memoize = singleLineComment / multiLineComment

singleLineComment -memoize -lexical = "//" (!eolChar .)*

multiLineComment -lexical  = "/*" (!"*/" .)* "*/"

eolChar = [\n\r\u2028\u2029]

EOL = '\n' / '\r' / '\r\n'
EOF = !.  / unexpected:&. #error{ "LLC0001: Unexpected '" + unexpected + "'" }