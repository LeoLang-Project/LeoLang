@namespace LeoLang.Core.AST
@classname LeoParser
@using LeoLang.Core.AST
@using LeoLang.Core.AST.Expressions

@start methodDefinition

//Literals
integerLiteral<SyntaxNode> = value:("" [0-9]+) {SyntaxNode.CreateInteger(value)}
decimalLiteral<SyntaxNode> = value:("" [0-9]+ "." [0-9]+) {SyntaxNode.CreateDecimal(value)}
hexLiteral<SyntaxNode> -public = "0x" value:("" [0-9A-Za-z]+) {SyntaxNode.CreateHexInteger(value)}
numberLiteral<SyntaxNode> = integerLiteral / decimalLiteral / hexLiteral

booleanLiteral<SyntaxNode> =  val:("true" / "false") { SyntaxNode.CreateBool(val) }
characterLiteral<SyntaxNode> = "'" c:("" [^']) "'" {SyntaxNode.CreateChar(c)}							
stringLiteral<SyntaxNode> = '"' val:("" simpleDoubleQuotedCharacter*) '"' {SyntaxNode.CreateString(val)}

value<SyntaxNode> -memoize = booleanLiteral / characterLiteral / stringLiteral / defaultExpression / sizeOfExpression / numberLiteral / identifier

identifier<SymbolNode> = id:("" ([a-zA-Z_][a-zA-Z_0-9]*)) {new SymbolNode(GSymbol.Get(id))}

expression<SyntaxNode> = binaryExpression / ternaryExpression/ value

binaryOperator<BinaryOperator> = "<=" {BinaryOperator.LessEq}
							   / ">=" {BinaryOperator.GreaterEq}
							   / "==" {BinaryOperator.Equal}
							   / "<" {BinaryOperator.Less}
							   / ">" {BinaryOperator.Greater};

binaryExpression<SyntaxNode> = lhs:value _? op:binaryOperator _? rhs:value {SyntaxNode.CreateBinary(lhs, op, rhs)}

ternaryExpression<SyntaxNode> -memoize = cond:binaryExpression _? "?" _? truePart:expression _? ":" _? falsePart:expression
										{SyntaxNode.CreateTernary(cond, truePart, falsePart)}
variableDefinition<SyntaxNode> = "let" _ id:identifier _ "=" _ val:expression 
										{SyntaxNode.CreateVarDef(id, val)}

label<SyntaxNode> = id:identifier Colon {SyntaxNode.CreateLabel(id)}

Block<SyntaxNode> -public = _? LCb _? block:blockContent _? RCb Semi
					{block}

blockContent<SyntaxNode> 
	= _? head:StatementLine _? tail:blockContent { SyntaxNode.CreateBlock(head).Concat(tail) }
	/ line:StatementLine { SyntaxNode.CreateBlock(line) }

	
parameterContent<SyntaxNode> -public
	= _? head:paramDef _? "," _? tail:parameterContent { SyntaxNode.CreateParameter(head).Concat(tail) }
	/ line:paramDef { SyntaxNode.CreateParameter(line) }


Statement<SyntaxNode> -public = goToStatement / variableDefinition / returnStatement / genericStatementBlock
StatementLine<SyntaxNode> -public = stmt:Statement Semi {stmt}
genericStatementBlock<SyntaxNode> -public = name:identifier _? LBr _? expr:expression _? RBr _? body:Block {SyntaxNode.CreateStatement(name, expr, body)}

paramDef<SyntaxNode> = type:identifier array:"[]"? _ name:identifier {SyntaxNode.CreateParameter(type, name, array)}
paramList<SyntaxNode> -memoize -public = parameterContent / paramListVoid
paramListVoid<SyntaxNode> = "void" {null}

methodDefinition<SyntaxNode> -public = ret:identifier _ id:identifier LBr param:paramList RBr body:Block
										{SyntaxNode.CreateMethod(id, ret, param, body)}	

defaultExpression<SyntaxNode> -public = "default" LBr id:identifier RBr {SyntaxNode.CreateDefault(id)}
										/ "default" {SyntaxNode.CreateDefault(null)}
sizeOfExpression<SyntaxNode> -public = "sizeof" LBr id:identifier RBr {SyntaxNode.CreateSizeOf(id)}

goToStatement<SyntaxNode> = "goto" _ id:identifier {SyntaxNode.CreateGoTo(id)}
returnStatement<SyntaxNode> -public = "return" _ expr:expression {SyntaxNode.CreateReturn(expr)} / "pass" {SyntaxNode.CreateReturn(null)}


//Tokens
LBr -lexical = '('
RBr -lexical = ')'
LCb -lexical = '{'
RCb -lexical = '}'
Semi -lexical = ';'
Colon -lexical = ':'

simpleDoubleQuotedCharacter
  = !('"' / "\\" / eolChar) char:. { @char }

whitespace = [\t ] / EOL
_ -memoize = (whitespace / EOL / comment)*

comment -memoize = singleLineComment / multiLineComment

singleLineComment -memoize -lexical = "//" (!eolChar .)*

multiLineComment -lexical  = "/*" (!"*/" .)* "*/"

eolChar = [\n\r\u2028\u2029]


EOL = '\n' / '\r' / '\r\n'
EOF = !.  / unexpected:&. #error{ "PEG0008: Unexpected '" + unexpected + "'" }